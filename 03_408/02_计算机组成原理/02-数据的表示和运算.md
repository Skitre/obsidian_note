## 数制与编码
### 进位计数制及其相互转换
- 在计算机系统内部，所有信息都是用二进制进行编码的，这样做的原因有以下几点：
	- 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低，例如用高低电平或电荷的正负极性都可以很方便地表示 0 和 1
	- 二进制位 1 和 0 正好与逻辑值“真”和“假”相对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件
	- 二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算
#### 进位计数法
- 常用的进位计数法有十进制(D)、二进制(B)、八进制(O)、十六进制(H、0x)等
- 基数
	- 每个数位所用到的*不同数码的个数*称为基数（十进制中为 10（0~9））
- 位权
	- 每个数码所表示的数值等于*该数码本身乘以一个与它所在数位有关的常数*，这个常数称为位权
	- 一个进位数的数值大小就是*它的各位数码**按权**相加*
#### 进制数转换
- 二进制 $\to$ 八进制、十六进制
	- *整数部分* 3 (4) 位一组，可在最左边*补 0*
	- *小数部分* 3 (4) 位一组，可在最右侧*补 0*
- 八进制、十六进制 $\to$ 二进制
	- 一位化为 3 (4) 位即可
- 任意进制 $\to$ 十进制
	- 按权展开
- 十进制 $\to$ 任意进制
	- 整数部分：*除基取余法*
		- 除基取余，先余为低，后余为高，商为 0 时结束
	- 小数部分：*乘积取整法*
		- 乘基取整，先整为高，后整为低，乘积为 1.0 (或满足精度要求) 时结束
### 定点数的编码表示
#### 基础概念
- 真值和机器数
	- 在日常生活中，通常用正号、负号来分别表示正数 (正号可省略)和负数，如 +15、-8 等，这种带“+”或“-”符号的数称为真值
	- **真值是机器数所代表的实际值**
	- 计算机中，通常*将符号和数值一起编码*，0 表示负，1 表示正，这种数字化的数称为机器数
- 机器数的定点表达
	- 根据*小数点的位置是否固定*，在计算机中分为定点表示和浮点表示
	- 通常用*补码整数表示整数*，用*原码小数表示浮点数的尾数部分*，用*移码表示浮点数的阶码部分*
	- 定点表示法用来表示*定点小数*和*定点整数*
- 定点小数是纯小数，约定小数点位置在符号位之后、有效数值部分最高位之前
	- ![[Pasted image 20250630152446.png]]
- 定点整数是纯整数，约定小数点位置在有效数值部分最低位之后
	- ![[Pasted image 20250630152511.png]]
#### 原码
- 定义：$$
[x]_{\text {原 }}=\left\{\begin{array}{ll}
0, x, & 0 \leqslant x<2^{n} \\
2^{n}-x=2^{n}+|x|, & -2^{n}<x \leqslant 0^{\prime}
\end{array}(x \text { 是真值, 字长为 } n+1)\right.
$$
- 用机器数的*最高位*表示数的*符号*，其余各位表示数的绝对值
- 范围：
	- 若字长为 n 位，则原码整数的表示范围为 ***$-(2^{n-1}-1)\le x \le 2^{n-1}-1$***
- 原码与真值的对应关系简单、直观，与真值的转换简单，用原码*实现乘除运算比较简便*
- 原码的 0 表示不唯一（$\pm 0$）, *加减法实现比较复杂*
#### 反码
- *正数*的反码是其*本身*，和原码表示法一致
- *负数*的反码是在其原码的基础上，*符号位不变，其余各个位取反*
#### 补码
- 定义 $$
\pm [x]_{\text {补 }}=\left\{\begin{array}{ll}
0, x, & 0 \leqslant x<2^{n} \\
2^{n+1}+x=2^{n+1}-|x|, & -2^{n} \leqslant x<0
\end{array} \quad\left(\bmod 2^{n+1}\right)\right.
$$
- 补码表示法中的加减运算统一采用加法操作实现
- 负数的补码等于模与该负数绝对值之差；
- 速算：
	- 基于原码，*除符号外，按位取反，末位+1*
- 范围：
	- 若字长为 n，则补码的表示范围为 $-2^{n-1}\le x \le 2^{n-1}-1$
- 变形补码：
	- 变形补码是一种采用双符号位的补码表示，也称模 4 补码
	- 假定变形补码的位数为 n+1 (其中符号位占 2 位，数值位占 n-1 位)
	- 模 4 补码双符号位 00 表示正，11 表示负，*用在执行算术运算的 ALU* 中
#### 移码
- 定义$$
[x]_\text{移 }=2^n+x(-2^n\leqslant x<2^n,\text{ 其中机器字长为 }n+1)
$$
- 移码常用来表示*浮点数的阶码*，它只能表示整数
- 移码就是在真值 x 上加上一个常数 (偏置值)，通常这个常数取 2n（在数轴上表现为全部右移至正数）
- 先求出当前数字的补码，然后在*补码的基础上，将其符号位取反*
- 移码保持了数据原有的大小顺序，移码大真值就大，移码小真值就小（便于比大小）
#### 总结
- 原码、补码、反码的符号位相同，正数的机器码相同。
- 原码、反码的表示在数轴上对称，二者都存在 +0 和 -0 两个 0。
- 补码、移码的表示在数轴上不对称，零的表示唯一，它们比原码、反码多表示一个数。
- 整数的补码、移码的符号位相反，数值位相同。
- 负数的补码、反码末位相差 1
- 原码很容易判断大小。而负数的补码、反码很难直接判断大小，可采用如下规则快速判断: 对于负数，数值位部分越小，其绝对值越大，即负得越多
#### 常用校验码
- 检验码是能够发现或能够自动纠正错误的数据编码
- 码距不小于 2 时开始有了检错能力，码距越大，检错能力就越强，且检错能力总是大于纠错能力
- 常用校验码有奇偶校验码、汉明码、CRC 循环码
- 奇偶校验码，在原始数据的最高位添加 1 或者 0，使其数据中的 1 恰好为奇数或者偶数
- 只能发现代码中奇数位出错的情况。常用在对存储器数据的检查或传输数据的检查中
- CRC 循环码，通常用于数据链路层，适合对大量数据校验。
## 运算方法和运算电路
### 基本运算部件
### 定点数的移位运算
- 当计算机中没有乘/除法运算电路时，可以通过*加法和移位相结合的方法来实现乘/除法运算*（列竖式 you konw？）
- 左移
	- 对于任意二进制整数，左移一位，若不产生溢出，相当于乘以 2
- 右移
	- 对于任意二进制整数，右移一位，若不考虑因移出而舍去的末位尾数，相当于除以 2
- 分类
	- 逻辑移位
		- 不考虑符号位，逻辑移位将操作数视为无符号整数 
		- 左移时，高位移出，低位补 0 
		- 右移时，低位移出，高位补 0 
		- 对于无符号整数的逻辑左移，若高位的 1 移出，则发生溢出
	- 算术移位
		- 算术移位需要*考虑符号位*的问题，即将操作数视为有符号整数
		- 计算机中的有符号整数都是用补码表示的，因此对于有符号整数的移位操作应*采用补码算术移位方式*
		- 左移时，高位移出，低位补 0 。若移出的高位不同于移位后的符号位，即左移前后的符号位不同，则发生溢出
		- 右移时，低位移出，高位补符号位，若低位的 1 移出，则影响精度
### 定点数的加减运算
#### 补码加减运算
$$\begin{gathered}
	、 [\mathrm{A+B}]_{补}=[\mathrm{A}]_{补}+[\mathrm{B}]_{补}\quad(\mathrm{mod} 2^{n+1}) \\
	 、[\mathrm{A-B}]_{补}=[\mathrm{A}]_{补}+[-\mathrm{B}]_{补}\quad(\mathrm{mod} 2^{n+1})
	 \end{gathered}$$
#### 溢出判别方法
- 溢出产生的情况
	- 仅当两个符号相同的数相加或两个符号相异的数相减才可能产生溢出
	- 如两个正数相加，而结果的符号位却为 1 (结果为负)
	- 或一个负数减去一个正数，结果的符号位却为 0 (结果为正)
- 一位符号位
	- 由于减法运算在机器中是用加法器实现的，因此无论是加法还是减法，只要：
		- 1. 参加操作的两个数的符号相同
		- 2. 结果与原操作数的符号不同
		- 结果就是溢出的
	- 逻辑电路实现：
		- A 的符号位为 $A_S$, B 的符号位为 $B_S$，运算结果的符号位为 $S_S$，
		- $V=A_SB_S\overline{S_{S}} + \overline{A_SB_S}S_S$
		- V=0 表示无溢出，V=1 表示有溢出
- 二位符号位
	- 双符号位法也称模 4 补码
	- 运算结果的两个符号位 Ss1 和 Ss2 相同，表示未溢出；
	- 运算结果的两个符号位 Ss1 和 Ss2 不同，表示溢出，此时*最高位符号位代表真正的符号*
#### 加减运算电路
- 已知一个数的补码表示为 Y ，则这个数的负数的补码为 Y 取反+1 
- 只要在原加法器的 Y 输入端加 n 个反向器以实现各位取反的功能，然后加一个 2 选 1多路选择器，用一个控制端 Sub 来控制，以选择是将 Y 输入加法器还是将 Y取反输入加法器，并将 Sub 同时作为低位进位送到加法器 (做减法时实现末位加 1 )
- ![[Pasted image 20250630172814.png]]
- 无符号整数相当于正整数的补码表示, 因此下图电路同时也能实现无符号数的加/减运算
- 有符号数 x 和 y ，图中 X 和 Y 分别是 x 和 y 的补码表示
- 对于无符号数 x 和 y ，图中 X 和 Y 分别是 x 和 y 的二进制表示
- *不论是补码减法还是无符号数减法，都是用被减数加上减数的负数的补码来实现的*
- ![[Pasted image 20250630172908.png]]
- 运算器本身无法识别所处理的二进制串是有符号数还是无符号数
#### 加减运算中的标志位
- ZF、OF、SF、CF
- F
	- *表示结果*
- ZF
	- *零标志位*，ZF=1 则结果为 0
- OF
	- *溢出标志位*
- SF
	- *结果符号位*
	- *对于无符号数运算无意义*
- CF
	- *进\借位标志*
	- 加法时： CF=1 表示结果溢出，因此 CF 等于进位输出 Cout
	- 减法时： CF=1 表示有借位，即不够减，故 CF 等于进位输出 Cout 取反
	- 综合可得 CF = Sub⊕ Cout
	- 对于*有符号数运算， CF 没有意义*
	- 无符号数比大小，当两个无符号数相减时
		- 若 A=B ，如 A-B=011-011=000 ，此时结果为零： ZF=1 ，无借位 CF=0 ；
		- 若 A>B ，如 A-B=010-001=001 ，此时结果非零： ZF=0 ，无借位 CF=0 ；
		- 若 A<B ，如 A-B=000-001=(1)000-001=111 ，此时： ZF=0 ，有借位 CF=1 ；
- 有符号为比大小，补码减，比较 ZF, OF 和 SF
	- ![[Pasted image 20250630173709.png]]
#### 原码的加减运算
- 在原码加减运算中，将符号位和数值位分开处理
- 加法
	- 遵循“同号求和，异号求差”的原则，先判断两个操作数的符号位
	- 符号位相同，则数值位相加，结果符号位不变，若最高数值位相加产生进位，则发生溢出
	- 符号位不同，则做减法，绝对值大的数减去绝对值小的数，结果符号位与绝对值大的数相同
- 减法
	- 先将减数的 符号取反 ，然后将被减数与符号取反后的减数按原码加法进行运算
### 定点数的乘除运算
#### 定点乘法运算
- 原码乘法（逻辑上）
	- 原码一位乘法【先加法再移位，重复n次(n位数值位长)】【移位是逻辑移位】 
	- 符号位单独运算：符号位=Xs⊕Ys 
	- 数值位取绝对值进行乘法计算 
	- 原码中移动的小数点的位数为——>两个乘法的小数点位数相加
	- ![[Pasted image 20250630180502.png]]
- *机器原码乘法*
	- 在正式进行乘法之前，ACC置 0
	- MQ中，若当前位=1，则ACC加被乘数、若当前位=0，则ACC加0【从最后一位开始计算】
	- 因为要发生错位，因此ACC连同MQ二者一起逻辑右移【此右移包括将ACC的数据右移到MQ中】
	- 手算机器乘法 ![[Pasted image 20250630180620.png]]
- 补码乘法
	- 补码一位乘法【进行n轮加法、移位，最后再多来一次加法】【移位是算术移位】【符号位参与运算】
	- 辅助位-MQ最低位 = 1时，(ACC)+[x]补 
	- 辅助位-MQ最低位 = 0时，(ACC)+0 
	- 辅助位-MQ最低位 = -1时，(ACC)+[-x]补
	- ![[Pasted image 20250630180800.png]]
	- 实现N位(不包括符号位)补码一位乘时，乘积为2N+1位 因为右移了n次——2N；再加上符号位2N+1

#### 除法运算
- n 位定点数的除法运算需统一为：
	- 一个 2n 位的数除以一个 n 位的数，得到一个 n 位的商
	- 因此需要对被除数进行扩展
- 对于定点正小数 (即原码小数)，只需在被除数低位添 n 个 0 即可对于定点正整数 (即无符号数)，只需在被除数高位添 n 个 0 即可。做整数除法时，若除数为 0, 则发生“除数为0”异常，此时需调出操作系统相应的异常处理程序进行处理
- 过程（列竖式）：
	- 1. 被除数与除数相减，够减则上商为 1，不够减则上商为 0；
	- 2. 每次得到的差为中间余数，将除数右移后与上次的中间余数比较；
	- 3. 用中间余数减除数够减则上商为 1，不够减则上商为 0；
	- 4. 如此重复，直到商的位数满足要求为止；
- 机器算法：恢复余数法
	- 若余数为负时商0，并加[|y|]补，再左移，再-|除数|
	- 符号单独处理
	- 数值位取绝对值进行除法计算
	- 计算机一开始默认上商1，如果错误再改上商0，并恢复余数
	- ![[Pasted image 20250630181308.png]]
- 加减交替法：
	- ![[Pasted image 20250630181442.png]]
- 补码除法
	- ![[Pasted image 20250630181507.png]]
## 浮点数的表示与运算
